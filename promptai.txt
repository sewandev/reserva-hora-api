<contexto>
    Eres un ingeniero de software senior con años en la industria de la informática, tu trabajor es ayudarme a construir una APP dandome siempre las respuestas más eficientes.
    Estoy trabajando una API RESTful con las versiones más recientes de Python con librerías adicionales que me ayudarán en el manejo de los datos.
    También estoy utilizando patrones de diseños mezclados para favorecer la modularidad y escabilidad a futuro del proyecto.

    Stack tecnologico:

    API RESTFul
    Python 3.13
    FastAPI 0.115
    SQLAlchemy 2.0.38
    Pydantic 2.10
    Uvicorn 0.34.0
    Pandas 2.2.3
    Openpyxl 3.1.5
    SQLite # Base de datos temporalmente para desarrollar el proyecto, a futuro migrará a PostgreSQL

    Estructura de archivos y carpetas:

    📁 reserva-hora-api                     # Directorio raíz del proyecto
    ├── 📁 app                              # Núcleo de la aplicación
    │   ├── 📁 api                          # Capa de API
    │   │   ├── 📁 endpoints                # Controladores específicos de la API
    │   │   │   ├── 📄 appointments.py      # Endpoints para gestión de citas
    │   │   │   ├── 📄 upload_schedules.py  # Endpoints para carga de horarios
    │   │   ├── 📄 routes.py                # Configuración central de rutas
    │   ├── 📁 core                         # Configuraciones centrales
    │   │   ├── 📄 config.py                # Variables de configuración y entorno
    │   │   ├── 📄 database.py              # Configuración de la base de datos
    │   ├── 📁 models                       # Capa de datos
    │   │   ├── 📄 models.py                # Modelos SQLAlchemy (entidades)
    │   ├── 📁 repositories                 # Capa de acceso a datos
    │   │   ├── 📄 appointments.py          # Repositorio para operaciones CRUD de citas
    │   │   ├── 📄 upload_schedules.py      # Repositorio para operaciones con horarios
    │   ├── 📁 schemas                      # Esquemas de datos
    │   │   ├── 📄 appointments.py          # Esquemas Pydantic para validación
    │   ├── 📁 services                     # Capa de lógica de negocio
    │   │   ├── 📄 appointments.py          # Servicios para gestión de citas
    │   │   ├── 📄 upload_schedules.py      # Servicios para procesamiento de horarios
    ├── 📄 .env                             # Variables de entorno
    ├── 📄 appointments.db                  # Base de datos SQLite
    ├── 📄 main.py                          # Punto de entrada de la aplicación
</contexto>

<reglas>
    1. Los nombres de variables, Funciones, Métodos, clases, archivos, carpetas deben ser siempre en inglés y claramente descriptivos siguiendo las convenciones de PEP 8.
    2. El código que me proporciones debe ir alineado al contexto, respetando el stack tecnologico y dividiendolo en las capas de responsabilidad que corresponda.
    3. Todos los comentarios que agregues sobre el código debe estar en español
</reglas>

<tareas>
    Basandote en el <contexto> y las <reglas> anteriormente mencionadas, 
    te entregaré el archivo repositories/appointments.py y la estructura de la BD y debes generar una consulta ORM de SQLAlchemy que cuando reciba los datos de una nueva consulta,
    valide el medic_id, is_reserved y que adicionalmente valide que la fecha y hora este dentro del rango horario del registrod de la tabla
</tareas>

<codigo>
#repositories/appointments.py

from sqlalchemy.ext.asyncio import AsyncSession # Es una sesión asíncrona de SQLAlchemy para interactuar con la base de datos de manera no bloqueante.
from sqlalchemy.exc import NoResultFound # Excepción que se lanza cuando no se encuentra un resultado en una consulta.
from sqlalchemy import select, and_ # Funciones de SQLAlchemy para construir consultas SQL.
from app.models.models import Appointment, AvailableSlot # Modelos de la base de datos que representan las tablas de citas y slots disponibles.
from app.schemas.appointments import AppointmentCreate # Esquema de validación para la creación de citas.

# Propósito: Esta clase encapsula la lógica para interactuar con la base de datos relacionada con las citas.
class AppointmentRepository:
    def __init__(self, db: AsyncSession): # Recibe una sesión de base de datos (AsyncSession) y la almacena en self.db
        self.db = db

    # Propósito: Método asincrónico que crea una nueva cita en la base de datos -> Retorna: Un objeto de tipo Appointment que representa la cita creada.
    async def create(self, data: AppointmentCreate) -> Appointment:

        # Verifica si el slot de tiempo solicitado está disponible para el médico (medic_id) en el horario especificado.
        slot = await self.db.execute(
            select(AvailableSlot).where(
                and_(
                    AvailableSlot.medic_id == data.medic_id,
                    AvailableSlot.start_time == data.start_time,
                    AvailableSlot.end_time == data.end_time,
                    AvailableSlot.is_reserved == False
                )
            )
            # SQL equivalente: SELECT * FROM available_slot WHERE medic_id = medic_id AND start_time = start_time AND end_time = end_time AND is_reserved = FALSE;
        )
        slot_result = slot.scalar()
        
        # Si no se encuentra un slot disponible, lanza una excepción.
        if not slot_result:
            raise NoResultFound("Slot not available")  # Excepción específica
        
        # Crear la cita
        new_appointment = Appointment(**data.model_dump())
        self.db.add(new_appointment)
        
        # Actualizar el estado del slot
        slot_result.is_reserved = True
        
        # Guardar los cambios
        await self.db.commit()
        await self.db.refresh(new_appointment)

        # Retorna los datos de la cita creada en la BD.
        return new_appointment

</codigo>